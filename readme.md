## Висновок

Виконавши різне сортування на різних розмірах масиву я отримав наступні результати

- **Малий масив (100 елементів):**
  - Сортування Timsort: 1.1720985639840364e-05 мс
  - Сортування злиттям: 0.0001917000045068562 мс
  - Сортування вставкою: 0.0001812959962990135 мс

  В цьому випадку Timsort набагато швидший за інші два алгоритми, що підтверджує його ефективність навіть на невеликих обсягах даних.

- **Середній масив (1000 елементів):**
  - Сортування Timsort: 0.0001162559783551842 мс
  - Сортування злиттям: 0.001906946999952197 мс
  - Сортування вставкою: 0.023871011013397947 мс

  На цьому обсязі даних Timsort також показує кращу ефективність, особливо порівняно з алгоритмом сортування вставкою, який стає значно повільнішим.

- **Великий масив (10000 елементів):**
  - Сортування Timsort: 0.0014017230132594705 мс
  - Сортування злиттям: 0.026099134993273765 мс
  - Сортування вставкою: 1.8160461079969537 мс
  
  На великому обсязі даних різниця у швидкості стає ще більш очевидною, і Timsort виявляється набагато ефективнішим за інші алгоритми.

Отже, можна зробити висновок, що поєднання сортування злиттям і сортування вставками в алгоритмі Timsort дійсно робить його набагато ефективнішим, особливо на великих обсягах даних. Тим самим, вбудовані алгоритми сортування в Python, такі як `sorted` і метод `sort`, які використовують Timsort, є чудовим вибором для більшості ситуацій, де потрібно виконати сортування.
